#version 450
#define THREADS_PER_WORKGROUP 128u

layout(push_constant) uniform Push {
    uint  startPos;   // inclusive
    uint  endPos;     // exclusive
    float multiple;
} pc;

layout(std430, set = 0, binding = 3) readonly  buffer RealPrefixSumBuf { float Re[]; }; // EXCLUSIVE per band, N+1 elems (P[0]=0)
layout(std430, set = 0, binding = 6) readonly  buffer ImagPrefixSumBuf { float Im[]; }; // EXCLUSIVE per band, N+1 elems (P[0]=0)
layout(std430, set = 0, binding = 4) writeonly buffer OutBuf       { float Y[]; }; // N elems per band
layout(std430, set = 0, binding = 2) readonly  buffer FreqBuf      { float frequency[]; };

layout (local_size_x = THREADS_PER_WORKGROUP) in;

void main() {
    const uint wg  = gl_WorkGroupID.x;          // band index
    const uint tid = gl_LocalInvocationID.x;

    const float f = frequency[wg];
    const uint  D = max(1u, uint((f > 0.0 ? (1.0 / f) : 0.0) * pc.multiple));

    const uint N = pc.endPos - pc.startPos;     // samples per band in this range
    if (N == 0u || D > N) return;

    // Per-band bases: P has N+1, Y has N
    const uint P_band_start = wg * (N + 1u);
    const uint Y_band_start = wg * N;

    uint l = D - 1u + tid; // first index where a full D-window ends
    while (l < N) {
        const uint r = l + 1u;      // right edge (exclusive) of window in P
        const uint l0 = r - D;      // left edge (inclusive) of window in P

        const float realWinSum =
            Re[P_band_start + r] - Re[P_band_start + l0];
        const float imagWinSum =
            Im[P_band_start + r] - Im[P_band_start + l0];

        Y[Y_band_start + l] = sqrt(realWinSum*realWinSum + imagWinSum*imagWinSum) / float(D);

        l += THREADS_PER_WORKGROUP;
    }


    // Optional: zero-fill first D outputs (l in [0..D-1]) if desired
    // for (uint z = tid; z < min(D, N); z += THREADS_PER_WORKGROUP)
    //     Y[Y_band_start + z] = 0.0;
}
